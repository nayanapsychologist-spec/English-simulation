<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simile Completion Drag and Drop</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the game board, ensuring it's centered and visually appealing */
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #e5e7eb; /* Light gray background */
        }
        #gameCanvas {
            /* Increased width to accommodate longer sentences */
            border: 4px solid #3b82f6; /* Blue border */
            background-color: #ffffff; /* White canvas background */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
            border-radius: 12px;
            cursor: default;
            touch-action: none; /* Prevents mobile scrolling while dragging */
        }
        h1 {
            color: #1e3a8a; /* Dark blue for title */
        }
        #message {
            padding: 12px;
            margin-top: 15px;
            border-radius: 8px;
            font-size: 1.15em;
            font-weight: 600;
            min-height: 40px;
            text-align: center;
        }
    </style>
</head>
<body class="p-4">

    <div class="max-w-5xl w-full flex flex-col items-center">
        <h1 class="text-3xl md:text-4xl font-extrabold mb-4">Simile Completion Activity</h1>
        <p class="text-gray-600 mb-6 text-center">Drag the simile phrases from the bottom to complete the sentences.</p>
        
        <!-- Canvas height increased from 500 to 550 to accommodate wrapped options -->
        <canvas id="gameCanvas" width="850" height="550"></canvas>
        
        <div id="message" class="w-full bg-yellow-100 text-yellow-800 border border-yellow-300">
            Drag a simile to begin!
        </div>

        <button id="resetButton" class="mt-6 px-6 py-2 bg-red-500 text-white font-semibold rounded-full hover:bg-red-600 transition duration-150 shadow-md hidden" onclick="initGame()">
            Reset Activity
        </button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const messageEl = document.getElementById('message');
        const resetButton = document.getElementById('resetButton');

        // --- Game Data (Similes Activity) ---
        const sentences = [
            { start: "I finished my exams. I am ", end: " now.", answer: "as free as a bird" },
            { start: "My puppy had a bath today. Its clean and soft fur is ", end: ".", answer: "as smooth as silk" },
            { start: "The waiter was back ", end: " with the food we ordered.", answer: "as quick as lightning" },
            { start: "We got the table repaired. Now it is ", end: ".", answer: "as good as new" },
            { start: "Hari came home very late. In anger, his father's face turned ", end: ".", answer: "as red as beet" },
            { start: "The pebbles on the river bank are ", end: ".", answer: "as fresh as a daisy" },
        ];

        const similes = [
            { text: "as free as a bird", correct: false },
            { text: "as smooth as silk", correct: false },
            { text: "as quick as lightning", correct: false },
            { text: "as good as new", correct: false },
            { text: "as red as beet", correct: false },
            { text: "as fresh as a daisy", correct: false },
            { text: "as cold as ice", correct: false }, // Decoy
            { text: "as brave as a lion", correct: false }, // Decoy
        ];

        // --- Configuration ---
        const SENTENCE_X_START = 20; // Starting position for the sentence number/text
        const ROW_HEIGHT = 60;
        const DRAGGABLE_Y_START = 380;
        const BOX_WIDTH = 150; // Width of the simile drop zone
        const BOX_HEIGHT = 40;
        const FONT_SIZE = '16px';
        const PADDING = 15;

        // --- Global State ---
        let draggables = [];
        let targets = [];
        let draggingItem = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        let isGameOver = false;

        // --- Setup Functions ---

        function initTargets() {
            targets = [];
            
            sentences.forEach((s, i) => {
                const y = PADDING + (i * ROW_HEIGHT) + ROW_HEIGHT;
                
                // Target box for the simile (the drop zone). X position is calculated dynamically in drawTable.
                targets.push({
                    x: 0, // Placeholder X, calculated at drawing time
                    y: y - BOX_HEIGHT / 2,
                    width: BOX_WIDTH, 
                    height: BOX_HEIGHT,
                    answer: s.answer,
                    isFilled: false,
                    filledText: '',
                    sentenceStart: s.start,
                    sentenceEnd: s.end,
                    index: i
                });
            });
        }

        function initDraggables() {
            draggables = [];
            // Shuffle the similes
            const shuffledSimiles = similes.slice().sort(() => Math.random() - 0.5);

            let currentX = PADDING;
            let currentY = DRAGGABLE_Y_START; // Start Y position

            shuffledSimiles.forEach(s => {
                ctx.font = `${FONT_SIZE} Arial`;
                const textWidth = ctx.measureText(s.text).width + PADDING * 2;
                
                // --- LINE WRAPPING LOGIC ---
                // Check if the current item goes beyond the right edge of the canvas (with padding margin)
                if (currentX + textWidth > canvas.width - PADDING) {
                    // Move to the next line (reset X, increment Y)
                    currentX = PADDING;
                    currentY += BOX_HEIGHT + PADDING; // Move down by box height + padding gap
                }
                // --- END LINE WRAPPING LOGIC ---

                draggables.push({
                    text: s.text,
                    x: currentX,
                    y: currentY, // Use dynamic Y
                    width: textWidth,
                    height: BOX_HEIGHT,
                    isCorrectlyPlaced: false,
                    originalX: currentX,
                    originalY: currentY // Store dynamic Y as original
                });
                
                // Advance X position for the next item
                currentX += textWidth + PADDING;
            });
        }
        
        // --- Drawing Functions ---

        function drawText(text, x, y, color = '#000', align = 'left') {
            ctx.fillStyle = color;
            ctx.font = `${FONT_SIZE} Arial`;
            ctx.textAlign = align;
            ctx.fillText(text, x, y);
        }

        function drawTable() {
            const SENTENCE_START_X_OFFSET = SENTENCE_X_START + 30; // Start text after the number

            // Draw table rows (sentences)
            targets.forEach((t, i) => {
                const y = t.y + BOX_HEIGHT / 2 + 10; // Text vertical center
                
                // 1. Sentence Number
                drawText(`(${i + 1})`, SENTENCE_X_START, y, '#444', 'left');

                // 2. Sentence Start Text
                // Measure the start text width to position the gap accurately
                const startText = t.sentenceStart;
                ctx.font = `${FONT_SIZE} Arial`;
                const startTextWidth = ctx.measureText(startText).width;
                
                drawText(startText, SENTENCE_START_X_OFFSET, y, '#333', 'left');
                
                const gapStart = SENTENCE_START_X_OFFSET + startTextWidth + 5; // X position of the gap
                t.x = gapStart; // Update target's actual X position

                // 3. Draw Target Box (the gap)
                if (!t.isFilled) {
                    ctx.strokeStyle = '#a3a3a3'; // Light gray for empty slot
                    ctx.strokeRect(gapStart, t.y, t.width, t.height);
                } else {
                    // Draw filled box (correctly placed)
                    ctx.fillStyle = '#10b981'; // Green for correct
                    ctx.fillRect(gapStart, t.y, t.width, t.height);
                    
                    // Draw text inside the box
                    drawText(t.filledText, gapStart + t.width / 2, y, '#fff', 'center');
                }

                // 4. Draw Sentence End Text
                const textAfterGapX = gapStart + t.width + 5;
                drawText(t.sentenceEnd, textAfterGapX, y, '#333', 'left');
                
                // 5. Draw divider line
                ctx.strokeStyle = '#d4d4d4';
                ctx.beginPath();
                ctx.moveTo(SENTENCE_X_START, y + 20);
                ctx.lineTo(canvas.width - PADDING, y + 20);
                ctx.stroke();
            });
        }

        function drawDraggables() {
            draggables.forEach(d => {
                if (!d.isCorrectlyPlaced) {
                    // Draw box
                    ctx.fillStyle = (d === draggingItem) ? '#f59e0b' : '#3b82f6'; // Orange if dragging, Blue otherwise
                    ctx.fillRect(d.x, d.y, d.width, d.height);

                    // Draw text
                    drawText(d.text, d.x + d.width / 2, d.y + 27, '#FFF', 'center');
                }
            });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawTable();
            drawDraggables();
            checkWinCondition();
        }

        // --- Interaction Logic ---
        function getCanvasPos(e) {
            const rect = canvas.getBoundingClientRect();
            // Handle touch events
            const clientX = e.clientX !== undefined ? e.clientX : e.changedTouches[0].clientX;
            const clientY = e.clientY !== undefined ? e.clientY : e.changedTouches[0].clientY;

            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function isOverItem(pos, item) {
            // Check if the given position is within the item's bounds
            return pos.x > item.x && pos.x < item.x + item.width &&
                   pos.y > item.y && pos.y < item.y + item.height;
        }
        
        function snapBack(item) {
            item.x = item.originalX;
            item.y = item.originalY;
            updateMessage("Item snapped back. Incorrect match or slot taken.", 'yellow');
        }
        
        function updateMessage(text, color = 'yellow') {
            const colors = {
                'green': 'bg-green-100 text-green-800 border-green-300',
                'red': 'bg-red-100 text-red-800 border-red-300',
                'yellow': 'bg-yellow-100 text-yellow-800 border-yellow-300',
                'blue': 'bg-blue-100 text-blue-800 border-blue-300',
            }
            messageEl.className = `w-full ${colors[color]} border px-3 py-2 rounded-lg mt-4`;
            messageEl.textContent = text;
        }

        function handleDown(e) {
            if (isGameOver) return;
            const pos = getCanvasPos(e);
            
            // 1. Check for a click on a draggable item (iterate backwards to check top items first)
            for (let i = draggables.length - 1; i >= 0; i--) {
                const item = draggables[i];
                if (!item.isCorrectlyPlaced && isOverItem(pos, item)) {
                    // Check if this text is already filling a slot (re-drag)
                    const target = targets.find(t => t.isFilled && t.filledText === item.text);
                    if (target) {
                        target.isFilled = false;
                        target.filledText = '';
                    }

                    draggingItem = item;
                    dragOffsetX = pos.x - item.x;
                    dragOffsetY = pos.y - item.y;
                    
                    // Bring the dragging item to the top visually
                    draggables.splice(i, 1);
                    draggables.push(draggingItem);
                    
                    draw(); 
                    return;
                }
            }
        }

        function handleMove(e) {
            if (draggingItem) {
                e.preventDefault();
                const pos = getCanvasPos(e);
                draggingItem.x = pos.x - dragOffsetX;
                draggingItem.y = pos.y - dragOffsetY;
                draw();
            }
        }

        function handleUp(e) {
            if (draggingItem) {
                e.preventDefault();
                const pos = getCanvasPos(e);

                let dropped = false;
                // 1. Check if dropped over a target box
                for (const target of targets) {
                    if (!target.isFilled && isOverItem(pos, target)) {
                        
                        // Check if the answer is correct
                        if (draggingItem.text === target.answer) {
                            // Correct drop
                            draggingItem.x = target.x;
                            draggingItem.y = target.y;
                            draggingItem.isCorrectlyPlaced = true;
                            target.isFilled = true;
                            target.filledText = draggingItem.text;
                            updateMessage("Excellent! You found the correct simile.", 'green');
                        } else {
                            // Incorrect drop - snap back
                            snapBack(draggingItem);
                            updateMessage("Oops! That simile doesn't fit the sentence. Try again.", 'red');
                        }
                        dropped = true;
                        break;
                    }
                }

                // 2. If dropped outside any open target box, snap back to origin
                if (!dropped) {
                    snapBack(draggingItem);
                }

                draggingItem = null;
                draw();
            }
        }

        function checkWinCondition() {
            const totalCorrect = draggables.filter(d => d.isCorrectlyPlaced).length;
            const requiredCorrect = sentences.length;
            
            if (totalCorrect === requiredCorrect) {
                isGameOver = true;
                updateMessage("🎉 Activity Complete! All sentences are correctly completed! 🎉", 'blue');
                resetButton.classList.remove('hidden');
                // Remove listeners to freeze the game
                canvas.removeEventListener('mousedown', handleMouseDown);
                canvas.removeEventListener('mousemove', handleMouseMove);
                canvas.removeEventListener('mouseup', handleMouseUp);
            } else {
                resetButton.classList.add('hidden');
            }
        }

        // --- Event Listener Mapping (Retained from previous version) ---
        function handleMouseDown(e) { handleDown(e); }
        function handleMouseMove(e) { handleMove(e); }
        function handleMouseUp(e) { handleUp(e); }
        
        function handleTouchStart(e) { if(e.touches.length === 1) handleDown(e.touches[0]); }
        function handleTouchMove(e) { if(e.touches.length === 1) handleMove(e.touches[0]); }
        function handleTouchEnd(e) { handleUp(e.changedTouches[0] || e); }

        function setupListeners() {
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            
            // Touch events for mobile
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);
        }

        // --- Main Initialization ---
        function initGame() {
            // Remove existing listeners before re-adding (for reset)
            canvas.removeEventListener('mousedown', handleMouseDown);
            canvas.removeEventListener('mousemove', handleMouseMove);
            canvas.removeEventListener('mouseup', handleMouseUp);
            canvas.removeEventListener('touchstart', handleTouchStart);
            canvas.removeEventListener('touchmove', handleTouchMove);
            canvas.removeEventListener('touchend', handleTouchEnd);

            isGameOver = false;
            draggingItem = null;
            resetButton.classList.add('hidden');

            initTargets();
            initDraggables();
            setupListeners();
            draw();
            updateMessage("Drag a simile to begin!", 'yellow');
        }

        window.onload = initGame;
    </script>
</body>
</html>
